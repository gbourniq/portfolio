---

apiVersion: v1
kind: ConfigMap
metadata:
  creationTimestamp: null
  name: postgres-env
data:
  POSTGRES_DB: myportfoliodb
  POSTGRES_INITDB_ARGS: "--encoding='UTF-8'"
  POSTGRES_PASSWORD: postgres
  POSTGRES_USER: postgres

---

apiVersion: v1
kind: ConfigMap
metadata:
  creationTimestamp: null
  name: postgres-config
data:
  postgres.conf: |+
    sten_addresses = '*'
    logging_collector = on
    log_directory = '/var/log/postgresql/'
    log_checkpoints = on
    log_line_prefix = '%m [%p] %q%u@%d '
    log_autovacuum_min_duration = 300

---

apiVersion: v1
kind: ConfigMap
metadata:
  creationTimestamp: null
  name: postgres-setup
data:
  run_db_setup.sh: |
    #!/bin/sh
    psql -U postgres -c "CREATE USER $POSTGRES_USER PASSWORD '$POSTGRES_PASSWORD'"
    psql -U postgres -c "CREATE DATABASE $POSTGRES_DB OWNER $POSTGRES_USER"
    psql -U postgres -c "GRANT ALL PRIVILEGES ON DATABASE $POSTGRES_DB TO $POSTGRES_USER"

---

kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: local-storage
provisioner: kubernetes.io/no-provisioner
reclaimPolicy: Retain
volumeBindingMode: WaitForFirstConsumer

---

# Note: While a local storage PV works, going with a more durable solution 
# (NFS, cloud option, etc.) is recommended
# https://kubernetes.io/blog/2018/04/13/local-persistent-volumes-beta/
apiVersion: v1
kind: PersistentVolume
metadata:
  name: postgres-pv
spec:
  capacity:
    storage: 1Gi
  volumeMode: Filesystem
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: pg-local-storage
  hostPath:
    path: /data/pgdata

---

apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: postgres-pvc
spec:
  accessModes:
  - ReadWriteOnce
  storageClassName: pg-local-storage
  resources:
    requests:
      storage: 1Gi

---

apiVersion: apps/v1
kind: StatefulSet
metadata:
  labels:
    app: postgres
  name: postgres
spec:
  serviceName: postgres
  replicas: 1
  selector:
    matchLabels:
      app: postgres
  template:
    metadata:
      labels:
        app: postgres
        role: db
    spec:
      volumes:
      - name: postgres-volume
        persistentVolumeClaim:
          claimName: postgres-pvc
      - name: config-volume
        configMap:
          name: postgres-config
      - name: setup-volume
        configMap:
          name: postgres-setup
      containers:
      - env:
        - name: POSTGRES_DB
          valueFrom:
            configMapKeyRef:
              key: POSTGRES_DB
              name: postgres-env
        - name: POSTGRES_PASSWORD
          valueFrom:
            configMapKeyRef:
              key: POSTGRES_PASSWORD
              name: postgres-env
        - name: POSTGRES_USER
          valueFrom:
            configMapKeyRef:
              key: POSTGRES_USER
              name: postgres-env
        - name: POSTGRES_INITDB_ARGS
          valueFrom:
            configMapKeyRef:
              key: POSTGRES_INITDB_ARGS
              name: postgres-env
        image: postgres:12-alpine
        imagePullPolicy: IfNotPresent
        name: postgres
        ports:
        - containerPort: 5432
        resources: {}   
        volumeMounts:
        - name: setup-volume
          mountPath: /docker-entrypoint-initdb.d/
          readOnly: false
        - name: config-volume
          mountPath: /etc/postgres/postgres.conf
          readOnly: true
        - mountPath: "/var/lib/postgresql/data"
          name: postgres-volume
        livenessProbe:
          exec:
            command:
            - bin/sh
            - -c
            - pg_isready -U postgres
          initialDelaySeconds: 0
          periodSeconds: 10
          failureThreshold: 10

---

apiVersion: v1
kind: Service
metadata:
  name: postgres
  labels:
    app: postgres
spec:
  selector:
    app: postgres
  ports:
  - name: "5432"
    port: 5432
    targetPort: 5432

---

kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: redis-local-storage
provisioner: kubernetes.io/no-provisioner
reclaimPolicy: Retain
volumeBindingMode: WaitForFirstConsumer

---

apiVersion: v1
kind: PersistentVolume
metadata:
  name: redis-pv
spec:
  capacity:
    storage: 1Gi
  volumeMode: Filesystem
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: redis-local-storage
  hostPath:
    path: /data/redisdata

---

apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: redis-pvc
spec:
  accessModes:
  - ReadWriteOnce
  storageClassName: redis-local-storage
  resources:
    requests:
      storage: 1Gi

---

apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: redis
  name: redis
spec:
  replicas: 1
  selector:
    matchLabels:
      app: redis
  template:
    metadata:
      labels:
        app: redis
        role: cache
    spec:
      volumes:
      - name: config-volume
        configMap:
          name: redis-config
      - name: redis-storage
        persistentVolumeClaim:
          claimName: redis-pvc
      containers:
      - image: redis:alpine
        imagePullPolicy: IfNotPresent
        name: redis
        ports:
        - containerPort: 6379
        resources: {}
        volumeMounts:
        - name: config-volume
          mountPath: /healthcheck/
          readOnly: false
        - name: redis-storage
          mountPath: /data/
        livenessProbe:
          exec:
            command:
            - sh
            - /healthcheck/redis_healthcheck.sh
          initialDelaySeconds: 20
          periodSeconds: 10
          failureThreshold: 10

---

apiVersion: v1
kind: Service
metadata:
  name: redis
  labels:
    app: redis
spec:
  selector:
    app: redis
  ports:
  - name: "6379"
    port: 6379
    targetPort: 6379

---

apiVersion: v1
kind: ConfigMap
metadata:
  creationTimestamp: null
  name: redis-config
data:
  redis_healthcheck.sh: "#!/bin/bash\nset -eo pipefail\nhost=\"$(hostname -i || echo
    '127.0.0.1')\"\nif ping=\"$(redis-cli -h \"$host\" ping)\" && [ \"$ping\" = 'PONG'
    ]; then\n\texit 0\nfi\nexit 1\n"
